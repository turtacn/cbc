// Code generated by Jules AI Test Generator. DO NOT EDIT.
package unit

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/turtacn/cbc/pkg/utils"
)

func TestStringToInt(t *testing.T) {
	tests := []struct {
		name         string
		input        string
		defaultValue int
		expected     int
	}{
		{"Valid integer", "123", 0, 123},
		{"Invalid integer", "abc", 99, 99},
		{"Empty string", "", 10, 10},
		{"Negative integer", "-5", 0, -5},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.expected, utils.StringToInt(tt.input, tt.defaultValue))
		})
	}
}

func TestStringToBool(t *testing.T) {
	tests := []struct {
		name  string
		input string
		want  bool
	}{
		{name: "Test true lowercase", input: "true", want: true},
		{name: "Test true uppercase", input: "TRUE", want: true},
		{name: "Test 1", input: "1", want: true},
		{name: "Test false", input: "false", want: false},
		{name: "Test 0", input: "0", want: false},
		{name: "Test empty", input: "", want: false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := utils.StringToBool(tt.input); got != tt.want {
				t.Errorf("StringToBool() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestToJSON(t *testing.T) {
	type sample struct {
		Name string `json:"name"`
		Age  int    `json:"age"`
	}
	s := sample{Name: "test", Age: 10}
	expected := `{"name":"test","age":10}`

	t.Run("Valid struct", func(t *testing.T) {
		result, err := utils.ToJSON(s)
		assert.NoError(t, err)
		assert.JSONEq(t, expected, result)
	})

	t.Run("Invalid type", func(t *testing.T) {
		_, err := utils.ToJSON(make(chan int))
		assert.Error(t, err)
	})
}

func TestFromJSON(t *testing.T) {
	type sample struct {
		Name string `json:"name"`
		Age  int    `json:"age"`
	}
	jsonStr := `{"name":"test","age":10}`
	expected := sample{Name: "test", Age: 10}

	t.Run("Valid JSON", func(t *testing.T) {
		var result sample
		err := utils.FromJSON(jsonStr, &result)
		assert.NoError(t, err)
		assert.Equal(t, expected, result)
	})

	t.Run("Invalid JSON", func(t *testing.T) {
		var result sample
		err := utils.FromJSON(`{"name":}`, &result)
		assert.Error(t, err)
	})
}

func TestBase64EncodeDecode(t *testing.T) {
	original := "hello world"

	t.Run("Standard encoding", func(t *testing.T) {
		encoded := utils.Base64EncodeString(original)
		decoded, err := utils.Base64DecodeString(encoded)
		assert.NoError(t, err)
		assert.Equal(t, original, decoded)
	})

	t.Run("URL encoding", func(t *testing.T) {
		encoded := utils.Base64URLEncode([]byte(original))
		decoded, err := utils.Base64URLDecode(encoded)
		assert.NoError(t, err)
		assert.Equal(t, original, string(decoded))
	})
}

func TestTimeToUnix(t *testing.T) {
	now := time.Now()
	unixTimestamp := now.Unix()
	assert.Equal(t, unixTimestamp, utils.TimeToUnix(now))
}

func TestUnixToTime(t *testing.T) {
	unixTimestamp := time.Now().Unix()
	expectedTime := time.Unix(unixTimestamp, 0)
	assert.Equal(t, expectedTime, utils.UnixToTime(unixTimestamp))
}

func TestStructToMap(t *testing.T) {
	type sample struct {
		Name string `json:"name"`
		Age  int    `json:"age"`
	}
	s := sample{Name: "John Doe", Age: 30}
	expectedMap := map[string]interface{}{"name": "John Doe", "age": float64(30)} // JSON unmarshals numbers to float64

	resultMap, err := utils.StructToMap(s)
	assert.NoError(t, err)
	assert.Equal(t, expectedMap, resultMap)
}

func TestMapToStruct(t *testing.T) {
	m := map[string]interface{}{"name": "John Doe", "age": 30}
	type sample struct {
		Name string `json:"name"`
		Age  int    `json:"age"`
	}
	expectedStruct := sample{Name: "John Doe", Age: 30}

	var resultStruct sample
	err := utils.MapToStruct(m, &resultStruct)
	assert.NoError(t, err)
	assert.Equal(t, expectedStruct, resultStruct)
}

func TestFormatFileSize(t *testing.T) {
	tests := []struct {
		name     string
		bytes    int64
		expected string
	}{
		{"Bytes", 500, "500 B"},
		{"Kilobytes", 1536, "1.5 KB"},
		{"Megabytes", 1572864, "1.5 MB"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.expected, utils.FormatFileSize(tt.bytes))
		})
	}
}

func TestMaskEmail(t *testing.T) {
	tests := []struct {
		name     string
		email    string
		expected string
	}{
		{"Standard email", "testuser@example.com", "t******r@example.com"},
		{"Short local part", "hi@example.com", "**@example.com"},
		{"Invalid email", "invalid-email", "***"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.expected, utils.MaskEmail(tt.email))
		})
	}
}

func TestRemoveDuplicates(t *testing.T) {
	slice := []string{"a", "b", "a", "c", "b"}
	expected := []string{"a", "b", "c"}
	assert.ElementsMatch(t, expected, utils.RemoveDuplicates(slice))
}

func TestToSnakeCase(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"CamelCase", "camel_case"},
		{"PascalCase", "pascal_case"},
		{"snake_case", "snake_case"},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			assert.Equal(t, tt.expected, utils.ToSnakeCase(tt.input))
		})
	}
}

func TestToCamelCase(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"snake_case", "snakeCase"},
		{"kebab-case", "kebabCase"},
		{"PascalCase", "pascalcase"},
	}

	for _, tt := range tests {
		t.Run(tt.input, func(t *testing.T) {
			assert.Equal(t, tt.expected, utils.ToCamelCase(tt.input))
		})
	}
}

func TestMapToQueryString(t *testing.T) {
	tests := []struct {
		name   string
		params map[string]string
		want   string
	}{
		{
			name:   "Test with multiple params",
			params: map[string]string{"key1": "value1", "key2": "value2"},
			want:   "key1=value1&key2=value2",
		},
		{
			name:   "Test with single param",
			params: map[string]string{"key1": "value1"},
			want:   "key1=value1",
		},
		{
			name:   "Test with no params",
			params: map[string]string{},
			want:   "",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.MapToQueryString(tt.params)
			// The order of params is not guaranteed, so we need to check for both possibilities
			if len(tt.params) > 1 {
				altWant := "key2=value2&key1=value1"
				if got != tt.want && got != altWant {
					t.Errorf("MapToQueryString() = %v, want %v or %v", got, tt.want, altWant)
				}
			} else {
				if got != tt.want {
					t.Errorf("MapToQueryString() = %v, want %v", got, tt.want)
				}
			}
		})
	}
}

func TestChunkSlice(t *testing.T) {
	tests := []struct {
		name      string
		slice     []string
		chunkSize int
		want      [][]string
	}{
		{
			name:      "Test with even chunks",
			slice:     []string{"a", "b", "c", "d"},
			chunkSize: 2,
			want:      [][]string{{"a", "b"}, {"c", "d"}},
		},
		{
			name:      "Test with uneven chunks",
			slice:     []string{"a", "b", "c", "d", "e"},
			chunkSize: 2,
			want:      [][]string{{"a", "b"}, {"c", "d"}, {"e"}},
		},
		{
			name:      "Test with chunk size larger than slice",
			slice:     []string{"a", "b"},
			chunkSize: 3,
			want:      [][]string{{"a", "b"}},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := utils.ChunkSlice(tt.slice, tt.chunkSize)
			assert.Equal(t, tt.want, got)
		})
	}
}
