// Code generated by Jules AI Test Generator. DO NOT EDIT.
package unit

import (
	"fmt"
	"testing"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/turtacn/cbc/pkg/utils"
)

func TestIsEmpty(t *testing.T) {
	tests := []struct {
		name  string
		input string
		want  bool
	}{
		{"Empty string", "", true},
		{"Whitespace only", "   ", true},
		{"With content", "hello", false},
		{"With leading/trailing space", "  world  ", false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.want, utils.IsEmpty(tt.input))
		})
	}
}

func TestValidateStringLength(t *testing.T) {
	tests := []struct {
		name    string
		value   string
		minLen  int
		maxLen  int
		wantErr bool
	}{
		{"Valid length", "abcde", 5, 10, false},
		{"Too short", "abc", 5, 10, true},
		{"Too long", "abcdefghijk", 5, 10, true},
		{"Exact min length", "abcde", 5, 10, false},
		{"Exact max length", "abcdefghij", 5, 10, false},
		{"No max length", "averylongstring", 5, 0, false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := utils.ValidateStringLength("test_field", tt.value, tt.minLen, tt.maxLen)
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestValidateEmail(t *testing.T) {
	tests := []struct {
		name    string
		email   string
		wantErr bool
	}{
		{"Valid email", "test@example.com", false},
		{"Invalid format", "test.example.com", true},
		{"Empty email", "", true},
		{"Disposable email", "user@mailinator.com", true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := utils.ValidateEmail("email_field", tt.email)
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestValidateURL(t *testing.T) {
	tests := []struct {
		name    string
		url     string
		wantErr bool
	}{
		{"Valid HTTP URL", "http://example.com", false},
		{"Valid HTTPS URL", "https://example.com/path", false},
		{"Invalid format", "not-a-url", true},
		{"Missing scheme", "example.com", true},
		{"Empty URL", "", true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := utils.ValidateURL("url_field", tt.url)
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestValidateUUID(t *testing.T) {
	validUUID := uuid.New().String()
	tests := []struct {
		name    string
		uuid    string
		wantErr bool
	}{
		{"Valid UUID", validUUID, false},
		{"Invalid UUID", "not-a-uuid", true},
		{"Empty UUID", "", true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := utils.ValidateUUID("uuid_field", tt.uuid)
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestValidateBearerToken(t *testing.T) {
	tests := []struct {
		name      string
		header    string
		wantToken string
		wantErr   bool
	}{
		{"Valid token", "Bearer my-secret-token", "my-secret-token", false},
		{"Missing Bearer prefix", "my-secret-token", "", true},
		{"Empty token", "Bearer ", "", true},
		{"Empty header", "", "", true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			token, err := utils.ValidateBearerToken(tt.header)
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.wantToken, token)
			}
		})
	}
}

func TestValidateScope(t *testing.T) {
	tests := []struct {
		name    string
		scope   string
		wantErr bool
	}{
		{"Valid single scope", "read", false},
		{"Valid multiple scopes", "read write:data", false},
		{"Invalid characters", "read!", true},
		{"Empty scope is allowed", "", false},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := utils.ValidateScope("scope_field", tt.scope)
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestValidatePassword(t *testing.T) {
	tests := []struct {
		name     string
		password string
		wantErr  bool
	}{
		{"Strong password", "Abcdef1!", false},
		{"Too short", "Abc1!", true},
		{"Missing uppercase", "abcdef1!", true},
		{"Missing lowercase", "ABCDEF1!", true},
		{"Missing digit", "Abcdefg!", true},
		{"Missing special char", "Abcdef12", true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := utils.ValidatePassword("password", tt.password)
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestValidateAll(t *testing.T) {
	t.Run("No errors", func(t *testing.T) {
		errors := utils.ValidateAll(
			func() error { return nil },
			func() error { return nil },
		)
		assert.False(t, errors.HasErrors())
	})

	t.Run("With errors", func(t *testing.T) {
		errors := utils.ValidateAll(
			func() error { return utils.NewValidationError("field1", "error1", "CODE1") },
			func() error { return nil },
			func() error { return utils.NewValidationError("field2", "error2", "CODE2") },
		)
		assert.True(t, errors.HasErrors())
		assert.Len(t, errors, 2)
		assert.Equal(t, "field1", errors[0].Field)
		assert.Equal(t, "field2", errors[1].Field)
	})
}

func TestSanitizeInput(t *testing.T) {
	tests := []struct {
		name  string
		input string
		want  string
	}{
		{
			name:  "Test with control characters",
			input: "hello\x00world",
			want:  "helloworld",
		},
		{
			name:  "Test with whitespace",
			input: "  hello world  ",
			want:  "hello world",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := utils.SanitizeInput(tt.input); got != tt.want {
				t.Errorf("SanitizeInput() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestValidateEnum(t *testing.T) {
	allowed := []string{"apple", "banana", "cherry"}
	tests := []struct {
		name    string
		value   string
		wantErr bool
	}{
		{"Valid value", "apple", false},
		{"Invalid value", "orange", true},
		{"Empty value", "", true},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := utils.ValidateEnum("fruit", tt.value, allowed)
			if tt.wantErr {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestValidateNoXSS(t *testing.T) {
    tests := []struct {
        name    string
        value   string
        wantErr bool
    }{
        {"Clean string", "Just a regular text.", false},
        {"Simple script tag", "<script>alert('XSS');</script>", true},
        {"Script tag with case variation", "<sCrIpT>alert('XSS');</sCrIpT>", true},
        {"Image with onerror", "<img src=x onerror=alert('XSS')>", true},
        {"Empty string", "", false},
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            err := utils.ValidateNoXSS("test_field", tt.value)
            if tt.wantErr {
                assert.Error(t, err, fmt.Sprintf("Expected an error for input: %s", tt.value))
                validationErr, ok := err.(*utils.ValidationError)
                assert.True(t, ok, "Error should be a ValidationError")
                assert.Equal(t, "XSS_VIOLATION", validationErr.Code)
            } else {
                assert.NoError(t, err, fmt.Sprintf("Expected no error for input: %s", tt.value))
            }
        })
    }
}
