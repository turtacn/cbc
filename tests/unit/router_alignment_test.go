// Code generated by Jules AI Test Generator. DO NOT EDIT.
package unit

import (
	"bytes"
	"crypto/rand"
	"crypto/rsa"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/turtacn/cbc/internal/application/dto"
	appMocks "github.com/turtacn/cbc/internal/application/service/mocks"
	"github.com/turtacn/cbc/internal/config"
	domainMocks "github.com/turtacn/cbc/internal/domain/service/mocks"
	"github.com/turtacn/cbc/internal/interfaces/http/handlers"
	httpRouter "github.com/turtacn/cbc/internal/interfaces/http/router"
	"github.com/turtacn/cbc/pkg/logger"
)

func Test_Routes_Are_Mounted(t *testing.T) {
	gin.SetMode(gin.TestMode)

	cfg := &config.Config{} // 默认即可
	log := logger.NewNoopLogger()

	mockAuthApp := new(domainMocks.AuthAppService)
	mockDeviceApp := new(domainMocks.DeviceAppService)
	mockDeviceAuthApp := new(appMocks.MockDeviceAuthAppService)
	mockKMS := new(domainMocks.KeyManagementService)
	mockRedis := new(domainMocks.RedisConnectionManager)

	// Mock any necessary method calls to prevent panics
	pk, _ := rsa.GenerateKey(rand.Reader, 2048)
	mockRedis.On("GetClient").Return(nil)
	mockRedis.On("Ping", mock.Anything).Return(nil)
	mockRedis.On("HealthCheck", mock.Anything).Return(map[string]interface{}{"status": "ok"}, nil)
	mockAuthApp.On("IssueToken", mock.Anything, mock.Anything).Return(&dto.TokenResponse{}, nil)
	mockAuthApp.On("RefreshToken", mock.Anything, mock.Anything).Return(&dto.TokenResponse{}, nil)
	mockAuthApp.On("RevokeToken", mock.Anything, mock.Anything).Return(nil)
	mockDeviceApp.On("RegisterDevice", mock.Anything, mock.Anything).Return(&dto.DeviceResponse{}, nil)
	mockDeviceApp.On("GetDeviceInfo", mock.Anything, mock.Anything).Return(&dto.DeviceResponse{}, nil)
	mockDeviceApp.On("UpdateDeviceInfo", mock.Anything, mock.Anything, mock.Anything).Return(&dto.DeviceResponse{}, nil)
	mockKMS.On("GetTenantPublicKeys", mock.Anything, mock.Anything).Return(map[string]*rsa.PublicKey{"kid-1": &pk.PublicKey}, nil)

	authHandler := handlers.NewAuthHandler(mockAuthApp, mockDeviceAuthApp, log)
	deviceHandler := handlers.NewDeviceHandler(mockDeviceApp, log)
	jwksHandler := handlers.NewJWKSHandler(mockKMS, log)
	healthHandler := handlers.NewHealthHandler(nil, mockRedis, log)
	oauthHandler := handlers.NewOAuthHandler(mockDeviceAuthApp)


	r := httpRouter.NewRouter(cfg, log, healthHandler, authHandler, deviceHandler, jwksHandler, oauthHandler, nil, nil, nil, nil)
	r.SetupRoutes()
	engine := r.Engine()

	testCases := []struct {
		method string
		path   string
		body   string
	}{
		{http.MethodGet, "/health/live", ""},
		{http.MethodGet, "/health/ready", ""},
		{http.MethodGet, "/live", ""},
		{http.MethodGet, "/ready", ""},
		{http.MethodPost, "/api/v1/auth/token", "{}"},
		{http.MethodPost, "/api/v1/auth/refresh", "{}"},
		{http.MethodPost, "/api/v1/auth/revoke", "{}"},
		{http.MethodGet, "/api/v1/auth/jwks/tenant-1", ""},
		{http.MethodPost, "/api/v1/devices", "{}"},
		{http.MethodGet, "/api/v1/devices/dev-1", ""},
		{http.MethodPut, "/api/v1/devices/dev-1", "{}"},
	}

	for _, tc := range testCases {
		t.Run(tc.path, func(t *testing.T) {
			req := httptest.NewRequest(tc.method, tc.path, bytes.NewBufferString(tc.body))
			req.Header.Set("Content-Type", "application/json")
			w := httptest.NewRecorder()
			engine.ServeHTTP(w, req)
			assert.NotEqual(t, http.StatusNotFound, w.Code, tc.path)
		})
	}
}
