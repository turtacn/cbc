// Code generated by Jules AI Test Generator. DO NOT EDIT.
package unit

import (
	"bytes"
	"crypto/rand"
	"crypto/rsa"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/turtacn/cbc/internal/application/dto"
	"github.com/turtacn/cbc/internal/config"
	"github.com/turtacn/cbc/internal/interfaces/http/handlers"
	httpRouter "github.com/turtacn/cbc/internal/interfaces/http/router"
	"github.com/turtacn/cbc/pkg/logger"
	"github.com/turtacn/cbc/tests/mocks"
)

func Test_Routes_Are_Mounted(t *testing.T) {
	gin.SetMode(gin.TestMode)

	cfg := &config.Config{} // 默认即可
	log := logger.NewNoopLogger()
	metrics := new(mocks.MockHTTPMetrics)
	metrics.On("RecordRequestStart", mock.Anything, mock.Anything).Return()
	metrics.On("RecordRequestDuration", mock.Anything, mock.Anything, mock.Anything, mock.AnythingOfType("time.Duration")).Return()
	metrics.On("RecordRequestError", mock.Anything, mock.Anything, mock.Anything).Return()

	mockAuthApp := new(mocks.MockAuthAppService)
	mockDeviceApp := new(mocks.MockDeviceAppService)
	mockCrypto := new(mocks.MockCryptoService)
	mockRedis := new(mocks.MockRedisConnectionManager)

	// Mock any necessary method calls to prevent panics
	pk, _ := rsa.GenerateKey(rand.Reader, 2048)
	mockRedis.On("GetClient").Return(nil)
	mockRedis.On("Ping", mock.Anything).Return(nil)
	mockRedis.On("HealthCheck", mock.Anything).Return(map[string]interface{}{"status": "ok"}, nil)
	mockAuthApp.On("IssueToken", mock.Anything, mock.Anything).Return(&dto.TokenResponse{}, nil)
	mockAuthApp.On("RefreshToken", mock.Anything, mock.Anything).Return(&dto.TokenResponse{}, nil)
	mockAuthApp.On("RevokeToken", mock.Anything, mock.Anything).Return(nil)
	mockDeviceApp.On("RegisterDevice", mock.Anything, mock.Anything).Return(&dto.DeviceResponse{}, nil)
	mockDeviceApp.On("GetDeviceInfo", mock.Anything, mock.Anything).Return(&dto.DeviceResponse{}, nil)
	mockDeviceApp.On("UpdateDeviceInfo", mock.Anything, mock.Anything, mock.Anything).Return(&dto.DeviceResponse{}, nil)
	mockCrypto.On("GetPrivateKey", mock.Anything, mock.Anything).Return(pk, "kid", nil)
	mockCrypto.On("GetPublicKey", mock.Anything, mock.Anything, mock.Anything).Return(&pk.PublicKey, nil)

	authHandler := handlers.NewAuthHandler(mockAuthApp, metrics, log)
	deviceHandler := handlers.NewDeviceHandler(mockDeviceApp, metrics, log)
	jwksHandler := handlers.NewJWKSHandler(mockCrypto, log, metrics)
	healthHandler := handlers.NewHealthHandler(nil, mockRedis, nil, log)

	r := httpRouter.NewRouter(cfg, log, healthHandler, authHandler, deviceHandler, jwksHandler, nil)
	r.SetupRoutes()
	engine := r.Engine()

	testCases := []struct {
		method string
		path   string
		body   string
	}{
		{http.MethodGet, "/health/live", ""},
		{http.MethodGet, "/health/ready", ""},
		{http.MethodGet, "/live", ""},
		{http.MethodGet, "/ready", ""},
		{http.MethodPost, "/api/v1/auth/token", "{}"},
		{http.MethodPost, "/api/v1/auth/refresh", "{}"},
		{http.MethodPost, "/api/v1/auth/revoke", "{}"},
		{http.MethodGet, "/api/v1/auth/jwks/tenant-1", ""},
		{http.MethodPost, "/api/v1/devices", "{}"},
		{http.MethodGet, "/api/v1/devices/dev-1", ""},
		{http.MethodPut, "/api/v1/devices/dev-1", "{}"},
	}

	for _, tc := range testCases {
		t.Run(tc.path, func(t *testing.T) {
			req := httptest.NewRequest(tc.method, tc.path, bytes.NewBufferString(tc.body))
			req.Header.Set("Content-Type", "application/json")
			w := httptest.NewRecorder()
			engine.ServeHTTP(w, req)
			assert.NotEqual(t, http.StatusNotFound, w.Code, tc.path)
		})
	}
}
