// Code generated by Jules AI Test Generator. DO NOT EDIT.
package unit

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/turtacn/cbc/internal/application/dto"
	appservice "github.com/turtacn/cbc/internal/application/service"
	"github.com/turtacn/cbc/internal/domain/models"
	"github.com/turtacn/cbc/pkg/constants"
	"github.com/turtacn/cbc/pkg/errors"
	"github.com/turtacn/cbc/pkg/logger"
)

type MockTokenService struct {
	mock.Mock
}

func (m *MockTokenService) IssueTokenPair(ctx context.Context, tenantID string, agentID string, deviceFingerprint string, scope []string, metadata map[string]interface{}) (refreshToken *models.Token, accessToken *models.Token, err error) {
	args := m.Called(ctx, tenantID, agentID, deviceFingerprint, scope, metadata)
	if args.Get(0) == nil {
		return nil, nil, args.Error(2)
	}
	return args.Get(0).(*models.Token), args.Get(1).(*models.Token), args.Error(2)
}

func (m *MockTokenService) RefreshToken(ctx context.Context, refreshTokenString string, requestedScope []string) (newRefreshToken *models.Token, accessToken *models.Token, err error) {
	args := m.Called(ctx, refreshTokenString, requestedScope)
	if args.Get(0) == nil {
		return nil, nil, args.Error(2)
	}
	return args.Get(0).(*models.Token), args.Get(1).(*models.Token), args.Error(2)
}

func (m *MockTokenService) VerifyToken(ctx context.Context, tokenString string, tokenType constants.TokenType, tenantID string) (*models.Token, error) {
	args := m.Called(ctx, tokenString, tokenType, tenantID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.Token), args.Error(1)
}

func (m *MockTokenService) RevokeToken(ctx context.Context, jti string, tenantID string, reason string) error {
	args := m.Called(ctx, jti, tenantID, reason)
	return args.Error(0)
}

func (m *MockTokenService) IsTokenRevoked(ctx context.Context, jti string) (bool, error) {
	args := m.Called(ctx, jti)
	return args.Bool(0), args.Error(1)
}

func (m *MockTokenService) GenerateAccessToken(ctx context.Context, refreshToken *models.Token, requestedScope []string) (*models.Token, error) {
	args := m.Called(ctx, refreshToken, requestedScope)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.Token), args.Error(1)
}

func (m *MockTokenService) ValidateTokenClaims(ctx context.Context, token *models.Token, validationContext map[string]interface{}) (bool, error) {
	args := m.Called(ctx, token, validationContext)
	return args.Bool(0), args.Error(1)
}

func (m *MockTokenService) IntrospectToken(ctx context.Context, tokenString string, tokenTypeHint string) (*models.TokenIntrospection, error) {
	args := m.Called(ctx, tokenString, tokenTypeHint)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.TokenIntrospection), args.Error(1)
}

func (m *MockTokenService) CleanupExpiredTokens(ctx context.Context, before time.Time) (int64, error) {
	args := m.Called(ctx, before)
	return args.Get(0).(int64), args.Error(1)
}


type MockBlacklistStore struct {
	mock.Mock
}

func (m *MockBlacklistStore) Revoke(ctx context.Context, tenantID, jti string, exp time.Time) error {
	args := m.Called(ctx, tenantID, jti, exp)
	return args.Error(0)
}

func (m *MockBlacklistStore) IsRevoked(ctx context.Context, tenantID, jti string) (bool, error) {
	args := m.Called(ctx, tenantID, jti)
	return args.Bool(0), args.Error(1)
}

func TestAuthAppService_RevokeToken(t *testing.T) {
	mockTokenService := new(MockTokenService)
	mockBlacklist := new(MockBlacklistStore)
	testLogger := logger.NewDefaultLogger()

	service := appservice.NewAuthAppService(
		mockTokenService,
		nil, // deviceRepo
		nil, // tenantRepo
		nil, // rateLimitService
		mockBlacklist,
		testLogger,
	)

	ctx := context.Background()
	tenantID := "test-tenant"
	jti := "test-jti"
	tokenStr := "some-token"

	t.Run("successful revocation", func(t *testing.T) {
		token := &models.Token{
			JTI:       jti,
			TenantID:  tenantID,
			DeviceID:  "device-1",
			TokenType: constants.TokenTypeAccess,
			ExpiresAt: time.Now().Add(time.Hour),
		}

		mockTokenService.On("VerifyToken", ctx, tokenStr, mock.Anything, tenantID).Return(token, nil).Once()
		mockBlacklist.On("Revoke", ctx, tenantID, jti, token.ExpiresAt).Return(nil).Once()

		req := &dto.RevokeTokenRequest{
			Token:    tokenStr,
			TenantID: tenantID,
			Reason:   "user logout",
		}

		err := service.RevokeToken(ctx, req)
		assert.NoError(t, err)

		mockTokenService.AssertExpectations(t)
		mockBlacklist.AssertExpectations(t)
	})

	t.Run("token verification fails", func(t *testing.T) {
		mockTokenService.On("VerifyToken", ctx, tokenStr, mock.Anything, tenantID).Return(nil, errors.ErrInvalidGrant("invalid token")).Once()

		req := &dto.RevokeTokenRequest{
			Token:    tokenStr,
			TenantID: tenantID,
		}

		err := service.RevokeToken(ctx, req)
		assert.NoError(t, err, "Should not return error on failed verification")

		mockTokenService.AssertExpectations(t)
	})

	t.Run("blacklist store fails", func(t *testing.T) {
		token := &models.Token{
			JTI:       jti,
			TenantID:  tenantID,
			DeviceID:  "device-1",
			TokenType: constants.TokenTypeAccess,
			ExpiresAt: time.Now().Add(time.Hour),
		}

		mockTokenService.On("VerifyToken", ctx, tokenStr, mock.Anything, tenantID).Return(token, nil).Once()
		mockBlacklist.On("Revoke", ctx, tenantID, jti, token.ExpiresAt).Return(errors.ErrServerError("redis error")).Once()

		req := &dto.RevokeTokenRequest{
			Token:    tokenStr,
			TenantID: tenantID,
		}

		err := service.RevokeToken(ctx, req)
		assert.Error(t, err)

		mockTokenService.AssertExpectations(t)
		mockBlacklist.AssertExpectations(t)
	})
}
