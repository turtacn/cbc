// Code generated by Jules AI Test Generator. DO NOT EDIT.
package unit

import (
	"context"
	"crypto/rand"
	"crypto/rsa"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"github.com/turtacn/cbc/internal/interfaces/http/middleware"
	"github.com/turtacn/cbc/pkg/errors"
	"github.com/turtacn/cbc/pkg/logger"
)

type MockCryptoService struct {
	mock.Mock
}

func (m *MockCryptoService) EncryptSensitiveData(ctx context.Context, data []byte) ([]byte, error) {
	args := m.Called(ctx, data)
	return args.Get(0).([]byte), args.Error(1)
}

func (m *MockCryptoService) DecryptSensitiveData(ctx context.Context, data []byte) ([]byte, error) {
	args := m.Called(ctx, data)
	return args.Get(0).([]byte), args.Error(1)
}

func (m *MockCryptoService) GenerateJWT(ctx context.Context, tenantID string, claims jwt.Claims) (string, string, error) {
	args := m.Called(ctx, tenantID, claims)
	return args.String(0), args.String(1), args.Error(2)
}

func (m *MockCryptoService) VerifyJWT(ctx context.Context, tokenString string, tenantID string) (jwt.MapClaims, error) {
	args := m.Called(ctx, tokenString, tenantID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(jwt.MapClaims), args.Error(1)
}

func (m *MockCryptoService) GetPublicKey(ctx context.Context, tenantID string, keyID string) (*rsa.PublicKey, error) {
	args := m.Called(ctx, tenantID, keyID)
	return args.Get(0).(*rsa.PublicKey), args.Error(1)
}

func (m *MockCryptoService) GetPrivateKey(ctx context.Context, tenantID string) (*rsa.PrivateKey, string, error) {
	args := m.Called(ctx, tenantID)
	return args.Get(0).(*rsa.PrivateKey), args.String(1), args.Error(2)
}

func (m *MockCryptoService) RotateKey(ctx context.Context, tenantID string) (string, error) {
	args := m.Called(ctx, tenantID)
	return args.String(0), args.Error(1)
}

func TestRequireJWT(t *testing.T) {
	gin.SetMode(gin.TestMode)
	testLogger := logger.NewDefaultLogger()

	// Mocks
	mockCrypto := new(MockCryptoService)
	mockBlacklist := new(MockBlacklistStore) // Reusing from app_auth_revoke_test

	// Middleware to test
	authMiddleware := middleware.RequireJWT(mockCrypto, mockBlacklist, testLogger)

	// Router setup
	router := gin.New()
	router.Use(authMiddleware)
	router.GET("/protected", func(c *gin.Context) {
		claims, exists := c.Get("claims")
		if !exists {
			c.AbortWithStatus(http.StatusInternalServerError)
			return
		}
		c.JSON(http.StatusOK, claims)
	})

	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
    require.NoError(t, err)

	t.Run("no authorization header", func(t *testing.T) {
		req, _ := http.NewRequest(http.MethodGet, "/protected", nil)
		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)
		assert.Equal(t, http.StatusUnauthorized, w.Code)
	})

	t.Run("token verification fails", func(t *testing.T) {
		jti := "some-jti"
		tenantID := "test-tenant"
		claims := jwt.MapClaims{"jti": jti, "tenant_id": tenantID}

		token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
		token.Header["kid"] = "test-kid"
		tokenStr, err := token.SignedString(privateKey)
		require.NoError(t, err)

		mockCrypto.On("VerifyJWT", mock.Anything, tokenStr, tenantID).Return(nil, errors.ErrTokenSignatureInvalid()).Once()

		req, _ := http.NewRequest(http.MethodGet, "/protected", nil)
		req.Header.Set("Authorization", "Bearer "+tokenStr)

		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusUnauthorized, w.Code)
		mockCrypto.AssertExpectations(t)
	})

	t.Run("token is revoked", func(t *testing.T) {
		jti := "revoked-jti"
		tenantID := "test-tenant"
		claims := jwt.MapClaims{"jti": jti, "tenant_id": tenantID}

		token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
		token.Header["kid"] = "test-kid"
		tokenStr, err := token.SignedString(privateKey)
		require.NoError(t, err)

		mockCrypto.On("VerifyJWT", mock.Anything, tokenStr, tenantID).Return(claims, nil).Once()
		mockBlacklist.On("IsRevoked", mock.Anything, tenantID, jti).Return(true, nil).Once()

		req, _ := http.NewRequest(http.MethodGet, "/protected", nil)
		req.Header.Set("Authorization", "Bearer "+tokenStr)

		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusUnauthorized, w.Code)
		mockCrypto.AssertExpectations(t)
		mockBlacklist.AssertExpectations(t)
	})

	t.Run("successful authentication", func(t *testing.T) {
		jti := "valid-jti"
		tenantID := "test-tenant"
		claims := jwt.MapClaims{"jti": jti, "tenant_id": tenantID, "exp": time.Now().Add(time.Hour).Unix()}

		token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
		token.Header["kid"] = "test-kid"
		tokenStr, err := token.SignedString(privateKey)
		require.NoError(t, err)

		mockCrypto.On("VerifyJWT", mock.Anything, tokenStr, tenantID).Return(claims, nil).Once()
		mockBlacklist.On("IsRevoked", mock.Anything, tenantID, jti).Return(false, nil).Once()

		req, _ := http.NewRequest(http.MethodGet, "/protected", nil)
		req.Header.Set("Authorization", "Bearer "+tokenStr)

		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusOK, w.Code)
		mockCrypto.AssertExpectations(t)
		mockBlacklist.AssertExpectations(t)
	})
}
