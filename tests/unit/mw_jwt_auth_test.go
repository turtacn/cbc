// Code generated by Jules AI Test Generator. DO NOT EDIT.
package unit

import (
	"crypto/rand"
	"crypto/rsa"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"github.com/turtacn/cbc/internal/domain/service/mocks"
	"github.com/turtacn/cbc/internal/interfaces/http/middleware"
	"github.com/turtacn/cbc/pkg/errors"
	"github.com/turtacn/cbc/pkg/logger"
)


func TestRequireJWT(t *testing.T) {
	gin.SetMode(gin.TestMode)
	testLogger := logger.NewDefaultLogger()

	// Mocks
	mockKMS := new(mocks.KeyManagementService)
	mockBlacklist := new(MockBlacklistStore) // Reusing from app_auth_revoke_test

	// Middleware to test
	authMiddleware := middleware.RequireJWT(mockKMS, mockBlacklist, testLogger)

	// Router setup
	router := gin.New()
	router.Use(authMiddleware)
	router.GET("/protected", func(c *gin.Context) {
		claims, exists := c.Get("claims")
		if !exists {
			c.AbortWithStatus(http.StatusInternalServerError)
			return
		}
		c.JSON(http.StatusOK, claims)
	})

	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
    require.NoError(t, err)

	t.Run("no authorization header", func(t *testing.T) {
		req, _ := http.NewRequest(http.MethodGet, "/protected", nil)
		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)
		assert.Equal(t, http.StatusUnauthorized, w.Code)
	})

	t.Run("token verification fails", func(t *testing.T) {
		jti := "some-jti"
		tenantID := "test-tenant"
		claims := jwt.MapClaims{"jti": jti, "tenant_id": tenantID}

		token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
		token.Header["kid"] = "test-kid"
		tokenStr, err := token.SignedString(privateKey)
		require.NoError(t, err)

		mockKMS.On("VerifyJWT", mock.Anything, tokenStr, tenantID).Return(nil, errors.ErrTokenSignatureInvalid()).Once()

		req, _ := http.NewRequest(http.MethodGet, "/protected", nil)
		req.Header.Set("Authorization", "Bearer "+tokenStr)

		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusUnauthorized, w.Code)
		mockKMS.AssertExpectations(t)
	})

	t.Run("token is revoked", func(t *testing.T) {
		jti := "revoked-jti"
		tenantID := "test-tenant"
		claims := jwt.MapClaims{"jti": jti, "tenant_id": tenantID}

		token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
		token.Header["kid"] = "test-kid"
		tokenStr, err := token.SignedString(privateKey)
		require.NoError(t, err)

		mockKMS.On("VerifyJWT", mock.Anything, tokenStr, tenantID).Return(claims, nil).Once()
		mockBlacklist.On("IsRevoked", mock.Anything, tenantID, jti).Return(true, nil).Once()

		req, _ := http.NewRequest(http.MethodGet, "/protected", nil)
		req.Header.Set("Authorization", "Bearer "+tokenStr)

		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusUnauthorized, w.Code)
		mockKMS.AssertExpectations(t)
		mockBlacklist.AssertExpectations(t)
	})

	t.Run("successful authentication", func(t *testing.T) {
		jti := "valid-jti"
		tenantID := "test-tenant"
		claims := jwt.MapClaims{"jti": jti, "tenant_id": tenantID, "exp": time.Now().Add(time.Hour).Unix()}

		token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
		token.Header["kid"] = "test-kid"
		tokenStr, err := token.SignedString(privateKey)
		require.NoError(t, err)

		mockKMS.On("VerifyJWT", mock.Anything, tokenStr, tenantID).Return(claims, nil).Once()
		mockBlacklist.On("IsRevoked", mock.Anything, tenantID, jti).Return(false, nil).Once()

		req, _ := http.NewRequest(http.MethodGet, "/protected", nil)
		req.Header.Set("Authorization", "Bearer "+tokenStr)

		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusOK, w.Code)
		mockKMS.AssertExpectations(t)
		mockBlacklist.AssertExpectations(t)
	})
}
