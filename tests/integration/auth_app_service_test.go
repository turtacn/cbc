
//go:build integration

// Code generated by Jules AI Test Generator. DO NOT EDIT.
package integration

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/turtacn/cbc/internal/application/dto"
	app_service "github.com/turtacn/cbc/internal/application/service"
	"github.com/turtacn/cbc/internal/domain/models"
	"github.com/turtacn/cbc/internal/domain/repository"
	"github.com/turtacn/cbc/internal/domain/service"
	"github.com/turtacn/cbc/pkg/constants"
	"github.com/turtacn/cbc/pkg/logger"
)

// MockTokenService is a mock implementation of domain.TokenService
type MockTokenService struct {
	mock.Mock
}

func (m *MockTokenService) IssueToken(ctx context.Context, tenantID, subject string, scope []string) (*models.Token, error) {
	args := m.Called(ctx, tenantID, subject, scope)
	return args.Get(0).(*models.Token), args.Error(1)
}

func (m *MockTokenService) IssueTokenPair(ctx context.Context, tenantID, agentID, deviceFingerprint string, scope []string, metadata map[string]interface{}) (*models.Token, *models.Token, error) {
	args := m.Called(ctx, tenantID, agentID, deviceFingerprint, scope, metadata)
	// This mock returns refreshToken first, then accessToken
	return args.Get(0).(*models.Token), args.Get(1).(*models.Token), args.Error(2)
}

func (m *MockTokenService) RefreshToken(ctx context.Context, refreshTokenString string, requestedScope []string) (*models.Token, *models.Token, error) {
	args := m.Called(ctx, refreshTokenString, requestedScope)
	// This mock returns newRefreshToken first, then newAccessToken
	return args.Get(0).(*models.Token), args.Get(1).(*models.Token), args.Error(2)
}

func (m *MockTokenService) VerifyToken(ctx context.Context, tokenString string, tokenType constants.TokenType, tenantID string) (*models.Token, error) {
	args := m.Called(ctx, tokenString, tokenType, tenantID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.Token), args.Error(1)
}

func (m *MockTokenService) RevokeToken(ctx context.Context, jti, tenantID, reason string) error {
	args := m.Called(ctx, jti, tenantID, reason)
	return args.Error(0)
}

func (m *MockTokenService) IsTokenRevoked(ctx context.Context, jti string) (bool, error) {
	args := m.Called(ctx, jti)
	return args.Bool(0), args.Error(1)
}

func (m *MockTokenService) GenerateAccessToken(ctx context.Context, refreshToken *models.Token, requestedScope []string) (*models.Token, error) {
	args := m.Called(ctx, refreshToken, requestedScope)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.Token), args.Error(1)
}

func (m *MockTokenService) ValidateTokenClaims(ctx context.Context, token *models.Token, validationContext map[string]interface{}) (bool, error) {
	args := m.Called(ctx, token, validationContext)
	return args.Bool(0), args.Error(1)
}

func (m *MockTokenService) IntrospectToken(ctx context.Context, tokenString, tokenTypeHint string) (*models.TokenIntrospection, error) {
	args := m.Called(ctx, tokenString, tokenTypeHint)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.TokenIntrospection), args.Error(1)
}

func (m *MockTokenService) CleanupExpiredTokens(ctx context.Context, before time.Time) (int64, error) {
	args := m.Called(ctx, before)
	return int64(args.Int(0)), args.Error(1)
}

// MockDeviceRepository is a mock implementation of repository.DeviceRepository
type MockDeviceRepository struct {
	mock.Mock
}

func (m *MockDeviceRepository) Save(ctx context.Context, device *models.Device) error {
	args := m.Called(ctx, device)
	return args.Error(0)
}

func (m *MockDeviceRepository) Update(ctx context.Context, device *models.Device) error {
	args := m.Called(ctx, device)
	return args.Error(0)
}

func (m *MockDeviceRepository) FindByID(ctx context.Context, agentID string) (*models.Device, error) {
	args := m.Called(ctx, agentID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.Device), args.Error(1)
}

func (m *MockDeviceRepository) FindByTenantID(ctx context.Context, tenantID string, limit, offset int) ([]*models.Device, int64, error) {
	args := m.Called(ctx, tenantID, limit, offset)
	return args.Get(0).([]*models.Device), int64(args.Int(1)), args.Error(2)
}

func (m *MockDeviceRepository) FindByFingerprint(ctx context.Context, tenantID, fingerprint string) (*models.Device, error) {
	args := m.Called(ctx, tenantID, fingerprint)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.Device), args.Error(1)
}

func (m *MockDeviceRepository) Exists(ctx context.Context, agentID string) (bool, error) {
	args := m.Called(ctx, agentID)
	return args.Bool(0), args.Error(1)
}

func (m *MockDeviceRepository) UpdateLastSeen(ctx context.Context, agentID string, lastSeenAt time.Time) error {
	args := m.Called(ctx, agentID, lastSeenAt)
	return args.Error(0)
}

func (m *MockDeviceRepository) UpdateTrustLevel(ctx context.Context, agentID string, trustLevel constants.TrustLevel) error {
	args := m.Called(ctx, agentID, trustLevel)
	return args.Error(0)
}

func (m *MockDeviceRepository) UpdateStatus(ctx context.Context, agentID string, status constants.DeviceStatus) error {
	args := m.Called(ctx, agentID, status)
	return args.Error(0)
}

func (m *MockDeviceRepository) Delete(ctx context.Context, agentID string) error {
	args := m.Called(ctx, agentID)
	return args.Error(0)
}

func (m *MockDeviceRepository) CountByTenantID(ctx context.Context, tenantID string) (int64, error) {
	args := m.Called(ctx, tenantID)
	return int64(args.Int(0)), args.Error(1)
}

func (m *MockDeviceRepository) CountActiveByTenantID(ctx context.Context, tenantID string) (int64, error) {
	args := m.Called(ctx, tenantID)
	return int64(args.Int(0)), args.Error(1)
}

func (m *MockDeviceRepository) FindInactiveDevices(ctx context.Context, inactiveSince time.Time, limit, offset int) ([]*models.Device, int64, error) {
	args := m.Called(ctx, inactiveSince, limit, offset)
	return args.Get(0).([]*models.Device), int64(args.Int(1)), args.Error(2)
}

func (m *MockDeviceRepository) FindByTrustLevel(ctx context.Context, tenantID string, trustLevel constants.TrustLevel, limit, offset int) ([]*models.Device, int64, error) {
	args := m.Called(ctx, tenantID, trustLevel, limit, offset)
	return args.Get(0).([]*models.Device), int64(args.Int(1)), args.Error(2)
}

func (m *MockDeviceRepository) BatchUpdateLastSeen(ctx context.Context, updates map[string]time.Time) error {
	args := m.Called(ctx, updates)
	return args.Error(0)
}

// MockTenantRepository is a mock implementation of repository.TenantRepository
type MockTenantRepository struct {
	mock.Mock
}

func (m *MockTenantRepository) Save(ctx context.Context, tenant *models.Tenant) error {
	args := m.Called(ctx, tenant)
	return args.Error(0)
}

func (m *MockTenantRepository) Update(ctx context.Context, tenant *models.Tenant) error {
	args := m.Called(ctx, tenant)
	return args.Error(0)
}

func (m *MockTenantRepository) FindByID(ctx context.Context, tenantID string) (*models.Tenant, error) {
	args := m.Called(ctx, tenantID)
	return args.Get(0).(*models.Tenant), args.Error(1)
}

func (m *MockTenantRepository) FindByName(ctx context.Context, name string) (*models.Tenant, error) {
	args := m.Called(ctx, name)
	return args.Get(0).(*models.Tenant), args.Error(1)
}

func (m *MockTenantRepository) FindAll(ctx context.Context, limit, offset int) ([]*models.Tenant, int64, error) {
	args := m.Called(ctx, limit, offset)
	return args.Get(0).([]*models.Tenant), int64(args.Int(1)), args.Error(2)
}

func (m *MockTenantRepository) FindActiveAll(ctx context.Context) ([]*models.Tenant, error) {
	args := m.Called(ctx)
	return args.Get(0).([]*models.Tenant), args.Error(1)
}

func (m *MockTenantRepository) Exists(ctx context.Context, tenantID string) (bool, error) {
	args := m.Called(ctx, tenantID)
	return args.Bool(0), args.Error(1)
}

func (m *MockTenantRepository) UpdateStatus(ctx context.Context, tenantID string, status constants.TenantStatus) error {
	args := m.Called(ctx, tenantID, status)
	return args.Error(0)
}

func (m *MockTenantRepository) UpdateRateLimitConfig(ctx context.Context, tenantID string, config *models.RateLimitConfig) error {
	args := m.Called(ctx, tenantID, config)
	return args.Error(0)
}

func (m *MockTenantRepository) UpdateTokenTTLConfig(ctx context.Context, tenantID string, config *models.TokenTTLConfig) error {
	args := m.Called(ctx, tenantID, config)
	return args.Error(0)
}

func (m *MockTenantRepository) UpdateKeyRotationPolicy(ctx context.Context, tenantID string, policy *models.KeyRotationPolicy) error {
	args := m.Called(ctx, tenantID, policy)
	return args.Error(0)
}

func (m *MockTenantRepository) Delete(ctx context.Context, tenantID string) error {
	args := m.Called(ctx, tenantID)
	return args.Error(0)
}

func (m *MockTenantRepository) GetTenantMetrics(ctx context.Context, tenantID string) (*repository.TenantMetrics, error) {
	args := m.Called(ctx, tenantID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*repository.TenantMetrics), args.Error(1)
}

func (m *MockTenantRepository) GetAllMetrics(ctx context.Context) (*repository.SystemMetrics, error) {
	args := m.Called(ctx)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*repository.SystemMetrics), args.Error(1)
}

func (m *MockTenantRepository) IncrementRequestCount(ctx context.Context, tenantID string, count int64) error {
	args := m.Called(ctx, tenantID, count)
	return args.Error(0)
}

func (m *MockTenantRepository) UpdateLastActivityAt(ctx context.Context, tenantID string, lastActivityAt time.Time) error {
	args := m.Called(ctx, tenantID, lastActivityAt)
	return args.Error(0)
}

// MockRateLimitService is a mock implementation of domain.RateLimitService
type MockRateLimitService struct {
	mock.Mock
}

func (m *MockRateLimitService) Allow(ctx context.Context, dimension service.RateLimitDimension, key, action string) (bool, int, time.Time, error) {
	args := m.Called(ctx, dimension, key, action)
	return args.Bool(0), args.Int(1), args.Get(2).(time.Time), args.Error(3)
}

// MockAuditService is a mock implementation of domain.AuditService
type MockAuditService struct {
	mock.Mock
}

func (m *MockAuditService) LogEvent(ctx context.Context, event models.AuditEvent) error {
	args := m.Called(ctx, event)
	return args.Error(0)
}

type MockBlacklistStore struct {
	mock.Mock
}

func (m *MockBlacklistStore) Revoke(ctx context.Context, tenantID, jti string, exp time.Time) error {
	args := m.Called(ctx, tenantID, jti, exp)
	return args.Error(0)
}

func (m *MockBlacklistStore) IsRevoked(ctx context.Context, tenantID, jti string) (bool, error) {
	args := m.Called(ctx, tenantID, jti)
	return args.Bool(0), args.Error(1)
}


func TestAuthAppService_RegisterDevice(t *testing.T) {
	// Setup
	mockTokenSvc := new(MockTokenService)
	mockDeviceRepo := new(MockDeviceRepository)
	mockTenantRepo := new(MockTenantRepository)
	mockRateLimitSvc := new(MockRateLimitService)
	mockBlacklist := new(MockBlacklistStore)
	mockAuditSvc := new(MockAuditService)
	log := logger.NewDefaultLogger()

	authService := app_service.NewAuthAppService(mockTokenSvc, mockDeviceRepo, mockTenantRepo, mockRateLimitSvc, mockBlacklist, mockAuditSvc, log)

	ctx := context.Background()
	req := &dto.RegisterDeviceRequest{
		TenantID:          "tenant-123",
		AgentID:           "agent-456",
		ClientID:          "client-789",
		DeviceFingerprint: "fingerprint-abc",
	}
	tenant := &models.Tenant{TenantID: "tenant-123", Status: constants.TenantStatusActive}
	refreshToken := &models.Token{JTI: "refresh-token-jti"}
	accessToken := &models.Token{JTI: "access-token-jti"}

	// Mocks
	mockTenantRepo.On("FindByID", ctx, req.TenantID).Return(tenant, nil)
	mockRateLimitSvc.On("Allow", ctx, service.RateLimitDimension("mgr"), fmt.Sprintf("mgr:%s:register", req.ClientID), "register").Return(true, 0, time.Time{}, nil)
	// When a device is not found, the repository should return (nil, nil)
	// The service layer interprets this as a trigger to create a new device.
	mockDeviceRepo.On("FindByID", ctx, req.AgentID).Return(nil, nil)
	mockDeviceRepo.On("Save", ctx, mock.AnythingOfType("*models.Device")).Return(nil)
	mockTokenSvc.On("IssueTokenPair", ctx, req.TenantID, req.AgentID, req.DeviceFingerprint, mock.Anything, mock.Anything).Return(refreshToken, accessToken, nil)
	mockAuditSvc.On("LogEvent", ctx, mock.Anything).Return(nil)

	// Execute
	resp, err := authService.RegisterDevice(ctx, req)

	// Assert
	assert.NoError(t, err)
	if !assert.NotNil(t, resp) {
		t.Fatal("response should not be nil")
	}
	assert.Equal(t, "access-token-jti", resp.AccessToken)
	assert.Equal(t, "refresh-token-jti", resp.RefreshToken)

	// Verify that all expectations were met
	mockTenantRepo.AssertExpectations(t)
	mockRateLimitSvc.AssertExpectations(t)
	mockDeviceRepo.AssertExpectations(t)
	mockTokenSvc.AssertExpectations(t)
}

func Test_RefreshToken_Rotation_E2E(t *testing.T) {
	// Setup
	mockTokenSvc := new(MockTokenService)
	mockDeviceRepo := new(MockDeviceRepository)
	mockTenantRepo := new(MockTenantRepository)
	mockRateLimitSvc := new(MockRateLimitService)
	mockBlacklist := new(MockBlacklistStore)
	mockAuditSvc := new(MockAuditService)
	log := logger.NewDefaultLogger()

	authService := app_service.NewAuthAppService(mockTokenSvc, mockDeviceRepo, mockTenantRepo, mockRateLimitSvc, mockBlacklist, mockAuditSvc, log)

	ctx := context.Background()
	// 1. (Setup) Create a valid Refresh Token A
	req := &dto.RefreshTokenRequest{
		RefreshToken: "refresh-token-A",
		TenantID:     "tenant-123",
	}
	tokenA := &models.Token{JTI: "jti-A", TenantID: "tenant-123", DeviceID: "agent-456", TokenType: constants.TokenTypeRefresh}

	// Mocks for Call 1
	mockTokenSvc.On("VerifyToken", ctx, "refresh-token-A", constants.TokenTypeRefresh, "tenant-123").Return(tokenA, nil).Once()
	mockBlacklist.On("IsRevoked", ctx, "tenant-123", "jti-A").Return(false, nil).Once()
	mockRateLimitSvc.On("Allow", ctx, service.RateLimitDimension("agent"), fmt.Sprintf("agent:%s:refresh", tokenA.DeviceID), "refresh").Return(true, 0, time.Time{}, nil).Once()
	mockDeviceRepo.On("FindByID", ctx, tokenA.DeviceID).Return(&models.Device{Status: constants.DeviceStatusActive}, nil).Once()
	mockBlacklist.On("Revoke", ctx, "tenant-123", "jti-A", mock.Anything).Return(nil).Once()
	tokenB := &models.Token{JTI: "jti-B", TenantID: "tenant-123", DeviceID: "agent-456"}
	accessTokenX := &models.Token{JTI: "access-token-X"}
	mockTokenSvc.On("IssueToken", ctx, "tenant-123", "agent-456", []string(nil)).Return(tokenB, nil).Once()
	mockTokenSvc.On("GenerateAccessToken", ctx, tokenA, []string(nil)).Return(accessTokenX, nil).Once()
	mockDeviceRepo.On("Update", ctx, mock.AnythingOfType("*models.Device")).Return(nil).Once()
	mockAuditSvc.On("LogEvent", ctx, mock.Anything).Return(nil).Times(4)

	// 2. (Call 1) Send a POST /api/v1/auth/token request with Refresh Token A.
	resp1, err1 := authService.RefreshToken(ctx, req)

	// 3. (Assert 1) Verify a 200 OK response. Parse the JSON body to get Access Token X and Refresh Token B. Verify Token A != Token B.
	assert.NoError(t, err1)
	assert.NotNil(t, resp1)
	assert.Equal(t, "access-token-X", resp1.AccessToken)
	assert.Equal(t, "jti-B", resp1.RefreshToken)
	assert.NotEqual(t, "refresh-token-A", resp1.RefreshToken)

	// 4. (Assert 2) Check the Redis blacklist; verify the JTI of Token A is now present.
	mockBlacklist.AssertCalled(t, "Revoke", ctx, "tenant-123", "jti-A", mock.Anything)

	// Mocks for Call 2
	mockTokenSvc.On("VerifyToken", ctx, "refresh-token-A", constants.TokenTypeRefresh, "tenant-123").Return(tokenA, nil).Once()
	mockBlacklist.On("IsRevoked", ctx, "tenant-123", "jti-A").Return(true, nil).Once()

	// 5. (Call 2) Send another POST /api/v1/auth/token request using the original Refresh Token A.
	resp2, err2 := authService.RefreshToken(ctx, req)

	// 6. (Assert 3) Verify a 400 Bad Request (invalid_grant) response.
	assert.Error(t, err2)
	assert.Nil(t, resp2)

	// Mocks for Call 3
	req.RefreshToken = "jti-B"
	tokenC := &models.Token{JTI: "jti-C", TenantID: "tenant-123"}
	accessTokenY := &models.Token{JTI: "access-token-Y"}
	mockTokenSvc.On("VerifyToken", ctx, "jti-B", constants.TokenTypeRefresh, "tenant-123").Return(tokenB, nil).Once()
	mockBlacklist.On("IsRevoked", ctx, "tenant-123", "jti-B").Return(false, nil).Once()
	mockRateLimitSvc.On("Allow", ctx, service.RateLimitDimension("agent"), fmt.Sprintf("agent:%s:refresh", tokenB.DeviceID), "refresh").Return(true, 0, time.Time{}, nil).Once()
	mockDeviceRepo.On("FindByID", ctx, tokenB.DeviceID).Return(&models.Device{Status: constants.DeviceStatusActive}, nil).Once()
	mockBlacklist.On("Revoke", ctx, "tenant-123", "jti-B", mock.Anything).Return(nil).Once()
	mockTokenSvc.On("IssueToken", ctx, "tenant-123", "agent-456", []string(nil)).Return(tokenC, nil).Once()
	mockTokenSvc.On("GenerateAccessToken", ctx, tokenB, []string(nil)).Return(accessTokenY, nil).Once()
	mockDeviceRepo.On("Update", ctx, mock.AnythingOfType("*models.Device")).Return(nil).Once()

	// 7. (Call 3) Send a POST /api/v1/auth/token request using the new Refresh Token B.
	resp3, err3 := authService.RefreshToken(ctx, req)

	// 8. (Assert 4) Verify a 200 OK response, returning Access Token Y and Refresh Token C.
	assert.NoError(t, err3)
	assert.NotNil(t, resp3)
	assert.Equal(t, "access-token-Y", resp3.AccessToken)
	assert.Equal(t, "jti-C", resp3.RefreshToken)
}
