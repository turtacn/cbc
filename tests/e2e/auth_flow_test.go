// Code generated by Jules AI Test Generator. DO NOT EDIT.
package e2e

import (
	"bytes"
	"context"
	"crypto/rand"
	"crypto/rsa"
	"encoding/json"
	"log"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"
	"github.com/turtacn/cbc/internal/application/dto"
	app_service "github.com/turtacn/cbc/internal/application/service"
	"github.com/turtacn/cbc/internal/config"
	domain_service "github.com/turtacn/cbc/internal/domain/service"
	postgres_infra "github.com/turtacn/cbc/internal/infrastructure/persistence/postgres"
	"github.com/turtacn/cbc/internal/interfaces/http/handlers"
	http_router "github.com/turtacn/cbc/internal/interfaces/http/router"
	"github.com/turtacn/cbc/pkg/logger"
	gormPostgres "gorm.io/driver/postgres"
	"gorm.io/gorm"
)

type AuthE2ESuite struct {
	suite.Suite
	db          *gorm.DB
	pgContainer *postgres.PostgresContainer
	router      *gin.Engine
}

func (s *AuthE2ESuite) SetupSuite() {
	if os.Getenv("SKIP_DOCKER_TESTS") == "true" {
		s.T().Skip("Skipping Docker-dependent tests")
	}
	ctx := context.Background()
	pgContainer, err := postgres.RunContainer(ctx,
		testcontainers.WithImage("postgres:15-alpine"),
		postgres.WithDatabase("e2e-db"),
		postgres.WithUsername("user"),
		postgres.WithPassword("password"),
		testcontainers.WithWaitStrategy(
			wait.ForLog("database system is ready to accept connections").
				WithOccurrence(2).
				WithStartupTimeout(5*time.Minute),
		),
	)
	if err != nil {
		log.Fatalf("failed to start postgres container: %s", err)
	}
	s.pgContainer = pgContainer

	connString, err := pgContainer.ConnectionString(ctx, "sslmode=disable")
	assert.NoError(s.T(), err)

	db, err := gorm.Open(gormPostgres.Open(connString), &gorm.Config{})
	assert.NoError(s.T(), err)
	s.db = db

	migrationsPath, _ := filepath.Abs("../../migrations/001_init_schema.up.sql")
	sqlBytes, err := os.ReadFile(migrationsPath)
	assert.NoError(s.T(), err)
	err = s.db.Exec(string(sqlBytes)).Error
	assert.NoError(s.T(), err)

	log := logger.NewDefaultLogger()
	cfg := &config.Config{}

	deviceRepo := postgres_infra.NewDeviceRepository(s.db, log)
	tenantRepo := postgres_infra.NewTenantRepository(s.db, log)
	tokenRepo := postgres_infra.NewTokenRepository(s.db, log)

	keyManager := &MockKeyManager{}
	rateLimiter := &MockRateLimitService{}
	rateLimiter.On("Allow", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(true, 0, time.Time{}, nil)

	tokenService := domain_service.NewTokenDomainService(tokenRepo, keyManager, log)
	authAppService := app_service.NewAuthAppService(tokenService, deviceRepo, tenantRepo, rateLimiter, log)
	deviceAppService := app_service.NewDeviceAppService(deviceRepo, log)

	authHandler := handlers.NewAuthHandler(authAppService, nil, log)
	deviceHandler := handlers.NewDeviceHandler(deviceAppService, nil, log)
	healthHandler := handlers.NewHealthHandler(nil, nil, nil, log)

	router := http_router.NewRouter(cfg, log, healthHandler, authHandler, deviceHandler)
	router.SetupRoutes()
	s.router = router.Engine()
}

func (s *AuthE2ESuite) TearDownSuite() {
	ctx := context.Background()
	assert.NoError(s.T(), s.pgContainer.Terminate(ctx))
}

func (s *AuthE2ESuite) SetupTest() {
	s.db.Exec("TRUNCATE TABLE devices, tokens, tenants RESTART IDENTITY CASCADE")
	tenantID := "a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11"
	s.db.Exec("INSERT INTO tenants (tenant_id, tenant_name, status) VALUES (?, 'E2E Test Tenant', 'active')", tenantID)
}

func (s *AuthE2ESuite) TestFullAuthFlow() {
	// 1. Register Device
	deviceID := uuid.New().String()
	regReqBody := dto.RegisterDeviceRequest{
		TenantID:          "a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11",
		AgentID:           deviceID,
		DeviceFingerprint: "e2e-fingerprint",
	}
	regJsonBody, _ := json.Marshal(regReqBody)
	req, _ := http.NewRequest(http.MethodPost, "/api/v1/auth/register-device", bytes.NewBuffer(regJsonBody))
	req.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	s.router.ServeHTTP(w, req)

	assert.Equal(s.T(), http.StatusCreated, w.Code)
	var regResp dto.TokenResponse
	err := json.Unmarshal(w.Body.Bytes(), &regResp)
	assert.NoError(s.T(), err)
	assert.NotEmpty(s.T(), regResp.RefreshToken)
	refreshToken := regResp.RefreshToken

	// 2. Issue Token using Refresh Token
	tokenReqBody := dto.RefreshTokenRequest{
		RefreshToken: refreshToken,
	}
	tokenJsonBody, _ := json.Marshal(tokenReqBody)
	req, _ = http.NewRequest(http.MethodPost, "/api/v1/auth/token", bytes.NewBuffer(tokenJsonBody))
	req.Header.Set("Content-Type", "application/json")

	w = httptest.NewRecorder()
	s.router.ServeHTTP(w, req)

	assert.Equal(s.T(), http.StatusOK, w.Code)
	var tokenResp dto.TokenResponse
	err = json.Unmarshal(w.Body.Bytes(), &tokenResp)
	assert.NoError(s.T(), err)
	assert.NotEmpty(s.T(), tokenResp.AccessToken)
	assert.NotEmpty(s.T(), tokenResp.RefreshToken)
}

func TestAuthE2ESuite(t *testing.T) {
	suite.Run(t, new(AuthE2ESuite))
}

type MockKeyManager struct {
	mock.Mock
}

func (m *MockKeyManager) GenerateJWT(ctx context.Context, tenantID string, claims jwt.Claims) (string, string, error) {
	args := m.Called(ctx, tenantID, claims)
	return args.String(0), args.String(1), args.Error(2)
}

func (m *MockKeyManager) VerifyJWT(ctx context.Context, tokenString string, tenantID string) (jwt.MapClaims, error) {
	args := m.Called(ctx, tokenString, tenantID)
	return args.Get(0).(jwt.MapClaims), args.Error(1)
}

func (m *MockKeyManager) GetPrivateKey(ctx context.Context, tenantID string) (*rsa.PrivateKey, string, error) {
	privateKey, _ := rsa.GenerateKey(rand.Reader, 2048)
	return privateKey, "test-kid", nil
}

func (m *MockKeyManager) GetPublicKey(ctx context.Context, tenantID, kid string) (*rsa.PublicKey, error) {
	privateKey, _ := rsa.GenerateKey(rand.Reader, 2048)
	return &privateKey.PublicKey, nil
}

func (m *MockKeyManager) DecryptSensitiveData(ctx context.Context, data []byte) ([]byte, error) {
	args := m.Called(ctx, data)
	return args.Get(0).([]byte), args.Error(1)
}

func (m *MockKeyManager) EncryptSensitiveData(ctx context.Context, data []byte) ([]byte, error) {
	args := m.Called(ctx, data)
	return args.Get(0).([]byte), args.Error(1)
}

func (m *MockKeyManager) RotateKey(ctx context.Context, tenantID string) (string, error) {
	args := m.Called(ctx, tenantID)
	return args.String(0), args.Error(1)
}

type MockRateLimitService struct {
	mock.Mock
}

func (m *MockRateLimitService) Allow(ctx context.Context, dimension domain_service.RateLimitDimension, key, action string) (bool, int, time.Time, error) {
	args := m.Called(ctx, dimension, key, action)
	return args.Bool(0), args.Int(1), args.Get(2).(time.Time), args.Error(3)
}
