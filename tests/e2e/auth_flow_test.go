// Code generated by Jules AI Test Generator. DO NOT EDIT.
package e2e

import (
	"bytes"
	"context"
	"encoding/json"
	"log"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/suite"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"
	"github.com/turtacn/cbc/internal/application/dto"
	app_service "github.com/turtacn/cbc/internal/application/service"
	"github.com/turtacn/cbc/internal/config"
	domain_service "github.com/turtacn/cbc/internal/domain/service"
	postgres_infra "github.com/turtacn/cbc/internal/infrastructure/persistence/postgres"
	"github.com/turtacn/cbc/internal/interfaces/http/handlers"
	http_router "github.com/turtacn/cbc/internal/interfaces/http/router"
	"github.com/turtacn/cbc/pkg/logger"
	"github.com/turtacn/cbc/tests/mocks"
	gormPostgres "gorm.io/driver/postgres"
	"gorm.io/gorm"
)

type AuthE2ESuite struct {
	suite.Suite
	db          *gorm.DB
	pgContainer *postgres.PostgresContainer
	router      *gin.Engine
}

func (s *AuthE2ESuite) SetupSuite() {
	if os.Getenv("SKIP_DOCKER_TESTS") == "true" {
		s.T().Skip("Skipping Docker-dependent tests")
	}
	ctx := context.Background()
	pgContainer, err := postgres.RunContainer(ctx,
		testcontainers.WithImage("postgres:15-alpine"),
		postgres.WithDatabase("e2e-db"),
		postgres.WithUsername("user"),
		postgres.WithPassword("password"),
		testcontainers.WithWaitStrategy(
			wait.ForLog("database system is ready to accept connections").
				WithOccurrence(2).
				WithStartupTimeout(5*time.Minute),
		),
	)
	if err != nil {
		log.Fatalf("failed to start postgres container: %s", err)
	}
	s.pgContainer = pgContainer

	connString, err := pgContainer.ConnectionString(ctx, "sslmode=disable")
	assert.NoError(s.T(), err)

	db, err := gorm.Open(gormPostgres.Open(connString), &gorm.Config{})
	assert.NoError(s.T(), err)
	s.db = db

	migrationsPath, _ := filepath.Abs("../../migrations/001_init_schema.up.sql")
	sqlBytes, err := os.ReadFile(migrationsPath)
	assert.NoError(s.T(), err)
	err = s.db.Exec(string(sqlBytes)).Error
	assert.NoError(s.T(), err)

	log := logger.NewDefaultLogger()
	cfg := &config.Config{}

	deviceRepo := postgres_infra.NewDeviceRepository(s.db, log)
	tenantRepo := postgres_infra.NewTenantRepository(s.db, log)
	tokenRepo := postgres_infra.NewTokenRepository(s.db, log)

	keyManager := &mocks.MockCryptoService{}
	rateLimiter := &mocks.MockRateLimitService{}
	rateLimiter.On("Allow", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(true, 0, time.Time{}, nil)

	tokenService := domain_service.NewTokenDomainService(tokenRepo, keyManager, log)
	authAppService := app_service.NewAuthAppService(tokenService, deviceRepo, tenantRepo, rateLimiter, log)
	deviceAppService := app_service.NewDeviceAppService(deviceRepo, log)

	metrics := &mocks.MockHTTPMetrics{}
	authHandler := handlers.NewAuthHandler(authAppService, metrics, log)
	deviceHandler := handlers.NewDeviceHandler(deviceAppService, metrics, log)
	healthHandler := handlers.NewHealthHandler(nil, nil, nil, log)
	jwksHandler := handlers.NewJWKSHandler(keyManager, log, metrics)

	router := http_router.NewRouter(cfg, log, healthHandler, authHandler, deviceHandler, jwksHandler)
	router.SetupRoutes()
	s.router = router.Engine()
}

func (s *AuthE2ESuite) TearDownSuite() {
	ctx := context.Background()
	assert.NoError(s.T(), s.pgContainer.Terminate(ctx))
}

func (s *AuthE2ESuite) SetupTest() {
	s.db.Exec("TRUNCATE TABLE devices, tokens, tenants RESTART IDENTITY CASCADE")
	tenantID := "a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11"
	s.db.Exec("INSERT INTO tenants (tenant_id, tenant_name, status) VALUES (?, 'E2E Test Tenant', 'active')", tenantID)
}

func (s *AuthE2ESuite) TestFullAuthFlow() {
	// 1. Register Device
	deviceID := uuid.New().String()
	regReqBody := dto.RegisterDeviceRequest{
		TenantID:          "a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11",
		AgentID:           deviceID,
		DeviceFingerprint: "e2e-fingerprint",
	}
	regJsonBody, _ := json.Marshal(regReqBody)
	req, _ := http.NewRequest(http.MethodPost, "/api/v1/devices", bytes.NewBuffer(regJsonBody))
	req.Header.Set("Content-Type", "application/json")

	w := httptest.NewRecorder()
	s.router.ServeHTTP(w, req)

	assert.Equal(s.T(), http.StatusCreated, w.Code)
	var regResp dto.DeviceResponse
	err := json.Unmarshal(w.Body.Bytes(), &regResp)
	assert.NoError(s.T(), err)
	assert.Equal(s.T(), deviceID, regResp.AgentID)

	// 2. Issue Token
	issueReqBody := dto.IssueTokenRequest{
		TenantID: "a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11",
		AgentID:  deviceID,
	}
	issueJsonBody, _ := json.Marshal(issueReqBody)
	req, _ = http.NewRequest(http.MethodPost, "/api/v1/auth/token", bytes.NewBuffer(issueJsonBody))
	req.Header.Set("Content-Type", "application/json")

	w = httptest.NewRecorder()
	s.router.ServeHTTP(w, req)

	assert.Equal(s.T(), http.StatusOK, w.Code)
	var tokenResp dto.TokenResponse
	err = json.Unmarshal(w.Body.Bytes(), &tokenResp)
	assert.NoError(s.T(), err)
	assert.NotEmpty(s.T(), tokenResp.AccessToken)
	assert.NotEmpty(s.T(), tokenResp.RefreshToken)
}

func TestAuthE2ESuite(t *testing.T) {
	suite.Run(t, new(AuthE2ESuite))
}
