// Code generated by Jules AI Test Generator. DO NOT EDIT.
package e2e

import (
	"bytes"
	"crypto/rand"
	"crypto/rsa"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/turtacn/cbc/internal/application/dto"
	"github.com/turtacn/cbc/internal/config"
	"github.com/turtacn/cbc/internal/interfaces/http/handlers"
	httpRouter "github.com/turtacn/cbc/internal/interfaces/http/router"
	"github.com/turtacn/cbc/pkg/logger"
	"github.com/turtacn/cbc/tests/mocks"
)

func TestAuthHttpSanity(t *testing.T) {
	gin.SetMode(gin.TestMode)
	log := logger.NewNoopLogger()
	metrics := new(mocks.MockHTTPMetrics)
	metrics.On("RecordRequestStart", mock.Anything, mock.Anything).Return()
	metrics.On("RecordRequestDuration", mock.Anything, mock.Anything, mock.Anything, mock.AnythingOfType("time.Duration")).Return()
	metrics.On("RecordRequestError", mock.Anything, mock.Anything, mock.Anything).Return()
	cfg := &config.Config{}

	// Mocks
	mockAuthApp := new(mocks.MockAuthAppService)
	mockDeviceApp := new(mocks.MockDeviceAppService)
	mockCrypto := new(mocks.MockCryptoService)
	mockRedis := new(mocks.MockRedisConnectionManager)

	// Mock any necessary method calls to prevent panics
	mockRedis.On("GetClient").Return(nil)
	mockRedis.On("Ping", mock.Anything).Return(nil)
	mockRedis.On("HealthCheck", mock.Anything).Return(map[string]interface{}{"status": "ok"}, nil)

	// Setup handlers
	authHandler := handlers.NewAuthHandler(mockAuthApp, metrics, log)
	deviceHandler := handlers.NewDeviceHandler(mockDeviceApp, metrics, log)
	jwksHandler := handlers.NewJWKSHandler(mockCrypto, log, metrics)
	healthHandler := handlers.NewHealthHandler(nil, mockRedis, nil, log)

	// Setup router
	router := httpRouter.NewRouter(cfg, log, healthHandler, authHandler, deviceHandler, jwksHandler, nil)
	router.SetupRoutes()
	engine := router.Engine()

	// 1. POST /api/v1/devices -> 201
	t.Run("RegisterDevice", func(t *testing.T) {
		mockDeviceApp.On("RegisterDevice", mock.Anything, mock.AnythingOfType("*dto.DeviceRegisterRequest")).Return(&dto.DeviceResponse{DeviceID: "dev-123"}, nil)
		reqBody := `{"tenant_id": "t-1", "agent_id": "agent-1", "device_fingerprint": "fp-1", "device_name": "test-device", "device_type": "desktop"}`
		req := httptest.NewRequest(http.MethodPost, "/api/v1/devices", bytes.NewBufferString(reqBody))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()
		engine.ServeHTTP(w, req)
		assert.Equal(t, http.StatusCreated, w.Code)
	})

	// 2. POST /api/v1/auth/token -> 200
	t.Run("IssueToken", func(t *testing.T) {
		mockAuthApp.On("IssueToken", mock.Anything, mock.AnythingOfType("*dto.TokenIssueRequest")).Return(&dto.TokenResponse{AccessToken: "fake-access-token"}, nil)
		reqBody := `{"grant_type": "device_credential", "client_id": "app-1", "client_secret": "secret", "tenant_id": "t-1", "agent_id": "agent-1"}`
		req := httptest.NewRequest(http.MethodPost, "/api/v1/auth/token", bytes.NewBufferString(reqBody))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()
		engine.ServeHTTP(w, req)
		assert.Equal(t, http.StatusOK, w.Code)
	})

	// 3. POST /api/v1/auth/refresh -> 200
	t.Run("RefreshToken", func(t *testing.T) {
		mockAuthApp.On("RefreshToken", mock.Anything, mock.AnythingOfType("*dto.TokenRefreshRequest")).Return(&dto.TokenResponse{AccessToken: "new-fake-access-token"}, nil)
		reqBody := `{"refresh_token": "fake-refresh-token", "tenant_id": "t-1"}`
		req := httptest.NewRequest(http.MethodPost, "/api/v1/auth/refresh", bytes.NewBufferString(reqBody))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()
		engine.ServeHTTP(w, req)
		assert.Equal(t, http.StatusOK, w.Code)
	})

	// 4. POST /api/v1/auth/revoke -> 204
	t.Run("RevokeToken", func(t *testing.T) {
		mockAuthApp.On("RevokeToken", mock.Anything, mock.AnythingOfType("*dto.TokenRevokeRequest")).Return(nil)
		reqBody := `{"token": "fake-access-token", "tenant_id": "t-1"}`
		req := httptest.NewRequest(http.MethodPost, "/api/v1/auth/revoke", bytes.NewBufferString(reqBody))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()
		engine.ServeHTTP(w, req)
		assert.Equal(t, http.StatusNoContent, w.Code)
	})

	// 5. GET /api/v1/auth/jwks/{tenant_id} -> 200
	t.Run("GetJWKS", func(t *testing.T) {
		pk, _ := rsa.GenerateKey(rand.Reader, 2048)
		mockCrypto.On("GetPublicKey", mock.Anything, "t-1", "kid-1").Return(&pk.PublicKey, nil)
		mockCrypto.On("GetPrivateKey", mock.Anything, "t-1").Return(pk, "kid-1", nil)

		req := httptest.NewRequest(http.MethodGet, "/api/v1/auth/jwks/t-1", nil)
		w := httptest.NewRecorder()
		engine.ServeHTTP(w, req)
		assert.Equal(t, http.StatusOK, w.Code)
		var jwks map[string]interface{}
		json.Unmarshal(w.Body.Bytes(), &jwks)
		assert.Contains(t, jwks, "keys")
	})
}
