// Code generated by Jules AI Test Generator. DO NOT EDIT.
package e2e

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"github.com/turtacn/cbc/internal/application/dto"
	"github.com/turtacn/cbc/internal/config"
	"github.com/turtacn/cbc/internal/domain/models"
	"github.com/turtacn/cbc/internal/domain/service"
	"github.com/turtacn/cbc/internal/interfaces/http/handlers"
	"github.com/turtacn/cbc/internal/interfaces/http/middleware"
	httpRouter "github.com/turtacn/cbc/internal/interfaces/http/router"
	"github.com/turtacn/cbc/pkg/logger"
	"github.com/turtacn/cbc/tests/fakes"
	"github.com/turtacn/cbc/tests/mocks"
)

// claimsFromToken is a helper to extract claims from a JWT for setting up test context
func claimsFromToken(t *testing.T, tokenStr string) jwt.MapClaims {
	claims, err := service.ParseJWTClaimsUnverified(tokenStr)
	require.NoError(t, err)
	return claims
}

func Test_HTTP_Auth_Revocation_E2E(t *testing.T) {
	gin.SetMode(gin.TestMode)
	log := logger.NewNoopLogger()
	cfg := &config.Config{}
	metrics := new(mocks.MockHTTPMetrics)
	metrics.On("RecordRequestStart", mock.Anything, mock.Anything).Maybe()
	metrics.On("RecordRequestDuration", mock.Anything, mock.Anything, mock.Anything, mock.Anything).Maybe()
	metrics.On("RecordRequestError", mock.Anything, mock.Anything, mock.Anything).Maybe()

	// Use a real crypto service to generate a real token
	cryptoService, err := service.NewJWTCryptoService("test-issuer", 15*time.Minute)
	require.NoError(t, err)

	// Use an in-memory fake for the blacklist
	fakeBlacklist := fakes.NewInMemoryTokenBlacklist()

	// Mocks for application services
	mockAuthApp := new(mocks.MockAuthAppService)
	mockDeviceApp := new(mocks.MockDeviceAppService)

	// Setup handlers
	authHandler := handlers.NewAuthHandler(mockAuthApp, nil, metrics, log)
	deviceHandler := handlers.NewDeviceHandler(mockDeviceApp, metrics, log)
	jwksHandler := handlers.NewJWKSHandler(cryptoService, log, metrics) // Use real crypto
	healthHandler := handlers.NewHealthHandler(nil, nil, log)

	// Setup Router with the REAL JWT middleware for the specific routes
	oauthHandler := handlers.NewOAuthHandler(nil)
	router := httpRouter.NewRouter(cfg, log, healthHandler, authHandler, deviceHandler, jwksHandler, oauthHandler, nil, nil, nil, nil)
	engine := router.Engine()

	// We manually set up routes to control middleware injection precisely
	v1 := engine.Group("/api/v1")
	{
		// Public routes from the main router setup
		auth := v1.Group("/auth")
		{
			auth.POST("/token", authHandler.IssueToken)
			auth.POST("/refresh", authHandler.RefreshToken)
			auth.POST("/revoke", authHandler.RevokeToken)
			auth.GET("/jwks/:tenant_id", jwksHandler.GetJWKS)
		}

		// Public device registration
		v1.POST("/devices", deviceHandler.RegisterDevice)

		// Protected routes with the REAL middleware
		deviceRoutes := v1.Group("/devices")
		deviceRoutes.Use(middleware.RequireJWT(cryptoService, fakeBlacklist, log))
		{
			// The handler expects device_id, not id
			deviceRoutes.GET("/:device_id", deviceHandler.GetDevice)
		}
	}

	// --- Test Scenario ---
	tenantID := "t-123"
	deviceID := "dev-abc-789"
	var accessToken string
	var tokenJTI string

	// 1. POST /api/v1/devices -> 201 (Register)
	t.Run("Step 1: Register Device", func(t *testing.T) {
		reqDto := dto.DeviceRegisterRequest{TenantID: tenantID, DeviceName: "E2E Test Device"}
		respDto := dto.DeviceResponse{DeviceID: deviceID}
		mockDeviceApp.On("RegisterDevice", mock.Anything, &reqDto).Return(&respDto, nil).Once()

		body, _ := json.Marshal(reqDto)
		req := httptest.NewRequest(http.MethodPost, "/api/v1/devices", bytes.NewBuffer(body))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		engine.ServeHTTP(w, req)
		assert.Equal(t, http.StatusCreated, w.Code)
	})

	// 2. POST /api/v1/auth/token -> 200 (Issue)
	t.Run("Step 2: Issue Token", func(t *testing.T) {
		claims := models.Claims{
			RegisteredClaims: jwt.RegisteredClaims{
				Issuer:    "test-issuer",
				Subject:   fmt.Sprintf("urn:cbc:device:%s", deviceID),
				Audience:  jwt.ClaimStrings{"api"},
				ExpiresAt: jwt.NewNumericDate(time.Now().Add(15 * time.Minute)),
				NotBefore: jwt.NewNumericDate(time.Now()),
				IssuedAt:  jwt.NewNumericDate(time.Now()),
				ID:        fmt.Sprintf("jti-%s", deviceID),
			},
			TenantID: tenantID,
			DeviceID: deviceID,
		}
		tokenJTI = claims.ID

		signedToken, _, err := cryptoService.GenerateJWT(context.Background(), tenantID, claims)
		require.NoError(t, err)
		accessToken = signedToken

		reqDto := dto.TokenIssueRequest{TenantID: tenantID, GrantType: "device_credential", ClientID: "test-client"}
		respDto := dto.TokenResponse{AccessToken: accessToken}
		mockAuthApp.On("IssueToken", mock.Anything, mock.AnythingOfType("*dto.TokenIssueRequest")).Return(&respDto, nil).Once()

		body, _ := json.Marshal(reqDto)
		req := httptest.NewRequest(http.MethodPost, "/api/v1/auth/token", bytes.NewBuffer(body))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()
		engine.ServeHTTP(w, req)

		assert.Equal(t, http.StatusOK, w.Code)
		var tokenResp dto.TokenResponse
		json.Unmarshal(w.Body.Bytes(), &tokenResp)
		assert.Equal(t, accessToken, tokenResp.AccessToken)
	})

	// 3. GET /api/v1/devices/{device_id} (with valid token) -> 200
	t.Run("Step 3: Access Protected Route with Valid Token", func(t *testing.T) {
		// The handler calls GetDeviceInfo, not GetDevice.
		// It also expects the tenantID from the context, which the mock must account for.
		mockDeviceApp.On("GetDeviceInfo", mock.Anything, deviceID).Return(&dto.DeviceResponse{DeviceID: deviceID}, nil).Once()

		req := httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/devices/%s", deviceID), nil)
		req.Header.Set("Authorization", "Bearer "+accessToken)
		w := httptest.NewRecorder()

		engine.ServeHTTP(w, req)
		assert.Equal(t, http.StatusOK, w.Code, "Expected OK but got: "+w.Body.String())
	})

	// 4. POST /api/v1/auth/revoke -> 204
	t.Run("Step 4: Revoke Token", func(t *testing.T) {
		mockAuthApp.On("RevokeToken", mock.Anything, mock.Anything).Run(func(args mock.Arguments) {
			req := args.Get(1).(*dto.TokenRevokeRequest)

			claims, err := service.ParseJWTClaimsUnverified(accessToken)
			require.NoError(t, err)

			exp := claims["exp"].(float64)
			expTime := time.Unix(int64(exp), 0)
			jti := claims["jti"].(string)

			// Manually add to our fake blacklist to simulate the app service logic
			fakeBlacklist.Revoke(context.Background(), req.TenantID, jti, expTime)
		}).Return(nil).Once()

		// The DTO expects 'token', not 'jti'.
		reqDto := dto.TokenRevokeRequest{TenantID: tenantID, Token: tokenJTI}
		body, _ := json.Marshal(reqDto)
		req := httptest.NewRequest(http.MethodPost, "/api/v1/auth/revoke", bytes.NewBuffer(body))
		req.Header.Set("Content-Type", "application/json")
		w := httptest.NewRecorder()

		engine.ServeHTTP(w, req)
		assert.Equal(t, http.StatusNoContent, w.Code)

		// Verify it's in the blacklist
		revoked, err := fakeBlacklist.IsRevoked(context.Background(), tenantID, tokenJTI)
		assert.NoError(t, err)
		assert.True(t, revoked)
	})

	// 5. GET /api/v1/devices/{device_id} (with revoked token) -> 401
	t.Run("Step 5: Access Protected Route with Revoked Token", func(t *testing.T) {
		req := httptest.NewRequest(http.MethodGet, fmt.Sprintf("/api/v1/devices/%s", deviceID), nil)
		req.Header.Set("Authorization", "Bearer "+accessToken)
		w := httptest.NewRecorder()

		engine.ServeHTTP(w, req)
		assert.Equal(t, http.StatusUnauthorized, w.Code)
	})
}
